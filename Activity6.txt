1)
empty stack S[1...6]
PUSH(S,4) - Adds "4" to the last slot of S so S[] = 4,~,~,~,~,~
PUSH(S,1) - Adds "1" to the last slot of S so S[] = 4,1,~,~,~,~
PUSH(S,3) - Adds "3" to the last slot of S so S[] = 4,1,3,~,~,~
POP(S) - removes the last slot of S so S[] = 4,1,~,~,~,~
PUSH(S,8) - Adds "8" to the last slot of S so S[] = 4,1,8,~,~,~
POP(S) - removes the last slot of S so S[] = 4,1,~,~,~,~

2) 
empty queue Q[1...6]
ENQUEUE(Q,4) - adds "4" to the last slot of Q so Q[] = 4,~,~,~,~,~
ENQUEUE(Q,1) - adds "1" to the last slot of Q so Q[] = 4,1,~,~,~,~
ENQUEUE(Q,3) - adds "3" to the last slot of Q so Q[] = 4,1,3,~,~,~
DEQUEUE(Q)   - removes the first slot of Q so Q[] = ~,1,3,~,~,~
ENQUEUE(Q,8) - adds "8" to the last slot of Q so Q[] = ~,1,3,8,~,~
DEQUEUE(Q)   - removes the first availible slot of Q so Q[] = ~,~,3,8,~,~

3)
BEFORE ADDING CHECK OVERFLOW
if (Q.tail+1 == Q.head) or (Q.tail == Q.length and Q.head == 1){
    //Overflow
else
    Q[Q.tail] = x
    if Q.tail + 1 == Q.head
    Q.tail = 1
    else Q.tail = Q.tail + 1
BEFORE REMOVING CHECK UNDERFLOW
if (Q.head == Q.tail){
    //Underflow
else
    x = Q[Q.head]
    if Q.head == Q.length   
        Q.head = 1
    else Q.head = Q.head + 1
    return x
4)
InsertFront (decrement front, insert at the front pointer)
InsertRear (decrement rear, insert at the rear)
DeleteFront (decrement front, Remove at the front pointer )
DeleteRear (decrement rear, remove at the rear pointer)